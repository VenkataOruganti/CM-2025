<?php
/**
 * Saree Blouse Pattern - PDF Export Generator
 *
 * This script generates a PDF file from pattern SVG content with tiling support.
 * It reads pattern data from the session (generated by sariBlouse.php)
 * and creates a multi-page PDF with:
 * - Front pattern
 * - Back pattern
 * - Patti pattern (border)
 * - Sleeve pattern
 *
 * Features:
 * - Multiple paper sizes (A4, A3, Letter, Legal, Tabloid)
 * - Landscape orientation for pattern layouts
 * - Automatic tiling for patterns larger than page size
 * - Scale verification box (2" × 2")
 * - Assembly markers for multi-page patterns
 *
 * Usage:
 * 1. First, generate pattern using sariBlouse.php
 * 2. Then access: sariBlouse_PDF.php?measurement_id=123&paper=A4
 * 3. PDF file downloads automatically
 *
 * Parameters:
 * - measurement_id: Measurement ID (optional - uses latest pattern if not specified)
 * - paper: Paper size (A4, A3, Letter, Legal, Tabloid - default: A4)
 *
 * Output:
 * - PDF file: CustomerName_123_patterns_2026-01-16_12-30-45.pdf
 *
 * @author CM-2025
 * @date January 16, 2026
 */

// Suppress PHP 8.5 deprecation warnings for TCPDF compatibility
error_reporting(E_ALL & ~E_DEPRECATED);

// Start output buffering to prevent any output before PDF generation
ob_start();

// Start session to access pattern data
session_start();

// Load TCPDF library
require_once(__DIR__ . '/../../../vendor/autoload.php');

// =============================================================================
// CONFIGURATION
// =============================================================================

// Paper sizes (in inches) - PORTRAIT orientation (default)
// Landscape dimensions used only for tiling
$paperSizes = [
    'A2' => ['portrait' => ['width' => 16.54, 'height' => 23.39], 'landscape' => ['width' => 23.39, 'height' => 16.54]],
    'A3' => ['portrait' => ['width' => 11.69, 'height' => 16.54], 'landscape' => ['width' => 16.54, 'height' => 11.69]],
    'A4' => ['portrait' => ['width' => 8.27, 'height' => 11.69], 'landscape' => ['width' => 11.69, 'height' => 8.27]],
    'Letter' => ['portrait' => ['width' => 8.5, 'height' => 11.0], 'landscape' => ['width' => 11.0, 'height' => 8.5]],
    'Legal' => ['portrait' => ['width' => 8.5, 'height' => 14.0], 'landscape' => ['width' => 14.0, 'height' => 8.5]],
    'Tabloid' => ['portrait' => ['width' => 11.0, 'height' => 17.0], 'landscape' => ['width' => 17.0, 'height' => 11.0]]
];

// Get paper size from URL parameter, session, or default to A3
// Priority: 1. URL parameter ($_GET['paper']), 2. Session preference ($_SESSION['paper_size']), 3. Default (A3)
if (isset($_GET['paper'])) {
    $paperSize = strtoupper($_GET['paper']);
} elseif (isset($_SESSION['paper_size'])) {
    $paperSize = strtoupper($_SESSION['paper_size']);
} else {
    $paperSize = 'A3'; // Default
}

// Validate paper size
if (!isset($paperSizes[$paperSize])) {
    $paperSize = 'A3'; // Fallback to A3 if invalid
}

// Start with portrait orientation (will switch to landscape for tiling if needed)
$paper = $paperSizes[$paperSize]['portrait'];
$paperOrientation = 'P'; // P = Portrait, L = Landscape

// Margins and layout
$margin = 0.3; // 0.3 inch margins (uniform on all sides)
$scale = 25.4; // Pixels per inch (matching sariBlouse.php)

// =============================================================================
// GET PATTERN DATA FROM SESSION
// =============================================================================

$patternData = null;
$cacheKey = null;

// Try to get pattern from URL parameters
if (isset($_GET['measurement_id'])) {
    $measurementId = intval($_GET['measurement_id']);
    $cacheKey = "pattern_" . $measurementId;

    if (isset($_SESSION[$cacheKey])) {
        $patternData = $_SESSION[$cacheKey]['data'];
    }
}

// Fallback: try to get latest pattern from session
if ($patternData === null && isset($_SESSION['latest_pattern'])) {
    $cacheKey = $_SESSION['latest_pattern'];
    if (isset($_SESSION[$cacheKey])) {
        $patternData = $_SESSION[$cacheKey]['data'];
    }
}

// Error if no pattern data found
if ($patternData === null) {
    ob_end_clean();
    http_response_code(400);
    die("ERROR: No pattern data found in session. Please generate a pattern first using sariBlouse.php");
}

// Extract pattern information
$customerName = $patternData['metadata']['customer_name'] ?? 'Customer';
$customerId = $patternData['metadata']['customer_id'] ?? 'unknown';
$measurementId = $patternData['metadata']['measurement_id'] ?? 'unknown';
$timestamp = date('Y-m-d_H-i-s');

// Sanitize customer name for filename
$safeCustomerName = preg_replace('/[^a-zA-Z0-9_-]/', '_', $customerName);
$pdfFilename = sprintf('%s_%s_patterns_%s.pdf', $safeCustomerName, $measurementId, $timestamp);

// =============================================================================
// HELPER FUNCTIONS
// =============================================================================

/**
 * Add CM logo to PDF page with website URL below it
 */
function addCMLogo($pdf, $pageWidth, $pageHeight) {
    $logoPath = __DIR__ . '/../../../images/cm-logo.svg';
    if (file_exists($logoPath)) {
        $logoWidth = 3.375;  // Increased by 50% more (2.25 * 1.5 = 3.375)
        $logoHeight = 3.375; // Increased by 50% more (2.25 * 1.5 = 3.375)
        // Position at absolute top edge (moving up 0.5" from the margin)
        $logoX = $pageWidth - $logoWidth - 0.5; // 0.5" from right edge
        $logoY = -0.5; // 0.5" above the page margin = at the absolute top edge

        $pdf->ImageSVG($logoPath, $logoX, $logoY, $logoWidth, $logoHeight, '', '', '', 0, false);

        // Add website URL right below the logo (no gap - almost touching)
        $pdf->SetFont('helvetica', 'B', 10); // Increased font size by 10% (9 -> 10)
        $pdf->SetTextColor(0, 102, 153); // Dark blue color for URL
        $urlText = 'www.CuttingMaster.in';
        $urlWidth = $pdf->GetStringWidth($urlText);
        // Right-align the URL under the logo with padding
        $urlX = $logoX + $logoWidth - $urlWidth - 0.2; // Right-aligned with 0.2" padding from logo right edge
        $urlY = $logoY + $logoHeight - 1.35; // Directly below logo (moved up 0.8" more)
        $pdf->Text($urlX, $urlY, $urlText);

        // Reset text color
        $pdf->SetTextColor(0, 0, 0);
    }
}

/**
 * Add watermark text in center of page (behind pattern)
 */
function addWatermark($pdf, $pageWidth, $pageHeight, $patternName, $customerName) {
    $pdf->SetAlpha(0.1); // Very transparent
    $pdf->SetFont('helvetica', 'B', 60);
    $pdf->SetTextColor(128, 128, 128); // Gray

    // Center position
    $centerX = $pageWidth / 2;
    $centerY = $pageHeight / 2;

    // Rotate and place watermark
    $pdf->StartTransform();
    $pdf->Rotate(45, $centerX, $centerY);
    $pdf->Text($centerX - 3, $centerY - 0.5, $patternName);
    $pdf->Text($centerX - 2, $centerY + 0.5, $customerName);
    $pdf->StopTransform();

    // Reset for pattern
    $pdf->SetAlpha(1);
    $pdf->SetTextColor(0, 0, 0);
}

/**
 * Draw scale verification box (2" × 2")
 */
function drawScaleBox($pdf, $x, $y) {
    $boxSize = 2.0;

    // Draw box
    $pdf->SetDrawColor(0, 0, 0);
    $pdf->SetLineWidth(1.5 / 72);
    $pdf->Rect($x, $y, $boxSize, $boxSize, 'D');

    // Draw gridlines (0.5" increments)
    for ($i = 0.5; $i < $boxSize; $i += 0.5) {
        $offset = $i;
        $pdf->SetLineWidth(0.5 / 72);
        $pdf->SetLineStyle(['dash' => '2,2']);
        $pdf->Line($x, $y + $offset, $x + $boxSize, $y + $offset);
        $pdf->Line($x + $offset, $y, $x + $offset, $y + $boxSize);
    }
    $pdf->SetLineStyle(['dash' => 0]);

    // Add labels
    $pdf->SetFont('helvetica', 'B', 10);
    $pdf->SetTextColor(0, 0, 0);
    $pdf->Text($x + 0.2, $y + 0.9, 'Printer');
    $pdf->Text($x + 0.2, $y + 1.1, 'Test');
    $pdf->SetFont('helvetica', '', 8);
    $pdf->Text($x + 0.6, $y + 2.15, '2" x 2" Scale');
}

/**
 * Add tile reference text to page (e.g., "Page 1 of 4" or "Tile 2 of 5")
 * Positioned below the logo and website URL
 */
function addTileReference($pdf, $pageWidth, $pageHeight, $tileNumber, $totalTiles, $patternName, $margin) {
    // Logo dimensions and position (must match addCMLogo function)
    $logoWidth = 3.375;
    $logoHeight = 3.375;
    $logoX = $pageWidth - $logoWidth - 0.5;
    $logoY = -0.5;

    // Position tile info below the logo and URL
    // Logo bottom: logoY + logoHeight = -0.5 + 3.375 = 2.875"
    // URL is at logoY + logoHeight - 1.35 = 1.525"
    // Place tile info below URL with small gap
    $tileInfoY = $logoY + $logoHeight - 1.15; // Below the URL (URL is at -1.35, so -1.15 is below it)

    // Center the tile info under the logo
    $centerX = $logoX + ($logoWidth / 2);

    // Set font and color
    $pdf->SetFont('helvetica', 'B', 11);
    $pdf->SetTextColor(0, 0, 0);

    // Prepare tile reference text
    if ($totalTiles == 1) {
        // Single page - just show pattern name
        $tileText = $patternName;
    } else {
        // Multi-page - show "Tile X of Y"
        $tileText = sprintf('Tile %d of %d', $tileNumber, $totalTiles);
    }

    // Calculate text width to center it
    $textWidth = $pdf->GetStringWidth($tileText);
    $x = $centerX - ($textWidth / 2);

    // Draw semi-transparent background box for better readability
    $pdf->SetAlpha(0.85);
    $pdf->SetFillColor(255, 255, 255);
    $boxWidth = $textWidth + 0.2;
    $boxHeight = 0.3;
    $pdf->Rect($x - 0.1, $tileInfoY - 0.05, $boxWidth, $boxHeight, 'F');
    $pdf->SetAlpha(1);

    // Add tile reference text
    $pdf->Text($x, $tileInfoY + 0.12, $tileText);

    // Reset text color
    $pdf->SetTextColor(0, 0, 0);
}

/**
 * Add corner registration marks (crosshairs) for tile alignment
 * @param object $pdf TCPDF instance
 * @param float $pageWidth Page width in inches
 * @param float $pageHeight Page height in inches
 * @param float $margin Page margin in inches
 * @param int $tileX Tile X position in grid (0-based)
 * @param int $tileY Tile Y position in grid (0-based)
 * @param int $tilesX Total tiles in X direction
 * @param int $tilesY Total tiles in Y direction
 */
function addRegistrationMarks($pdf, $pageWidth, $pageHeight, $margin, $tileX, $tileY, $tilesX, $tilesY) {
    $markSize = 0.25; // 0.25" crosshair size
    $circleRadius = 0.08; // Circle radius in inches

    // Set line properties for registration marks
    $pdf->SetLineStyle([
        'width' => 0.012, // Thin line (0.012")
        'cap' => 'round',
        'join' => 'round',
        'dash' => 0,
        'color' => [0, 0, 0] // Black
    ]);

    /**
     * CRITICAL FIX: Every tile gets marks on ALL 4 CORNERS!
     *
     * Why? When overlapping tiles:
     * - Tile A's TOP-RIGHT mark must align with Tile B's TOP-LEFT mark
     * - Tile A's BOTTOM-LEFT mark must align with Tile C's TOP-LEFT mark
     * - Etc.
     *
     * If we omit marks on some tiles, adjacent tiles won't have matching marks to align!
     *
     * Example 2×2 Grid:
     * ┌───────┬───────┐
     * │ T1    │ T2    │
     * │ ⊕───⊕ │ ⊕───⊕ │  ← T1.TR must overlap with T2.TL
     * ├───────┼───────┤
     * │ ⊕───⊕ │ ⊕───⊕ │  ← T1.BL must overlap with T3.TL
     * │ T3    │ T4    │
     * └───────┴───────┘
     */

    // ALL tiles get ALL 4 corner marks
    $corners = [
        ['x' => $margin, 'y' => $margin, 'label' => 'TL'],
        ['x' => $pageWidth - $margin, 'y' => $margin, 'label' => 'TR'],
        ['x' => $margin, 'y' => $pageHeight - $margin, 'label' => 'BL'],
        ['x' => $pageWidth - $margin, 'y' => $pageHeight - $margin, 'label' => 'BR']
    ];

    // Draw registration marks at each corner
    foreach ($corners as $corner) {
        $x = $corner['x'];
        $y = $corner['y'];

        // Draw circle
        $pdf->Circle($x, $y, $circleRadius, 0, 360, 'D');

        // Draw horizontal crosshair line
        $pdf->Line($x - $markSize, $y, $x + $markSize, $y);

        // Draw vertical crosshair line
        $pdf->Line($x, $y - $markSize, $x, $y + $markSize);

        // Optional: Add small label for debugging
        // Uncomment to see which corner is which during testing
        // $pdf->SetFont('helvetica', '', 6);
        // $pdf->Text($x + 0.15, $y + 0.05, $corner['label'] . " [Tile " . ($tileY * $tilesX + $tileX + 1) . "]");
    }
}

/**
 * Add diagonal alignment lines across tile overlap zones
 * These lines help visually confirm perfect alignment when assembling tiles
 * @param object $pdf TCPDF instance
 * @param float $pageWidth Page width in inches
 * @param float $pageHeight Page height in inches
 * @param float $margin Page margin in inches
 * @param int $tileX Tile X position in grid (0-based)
 * @param int $tileY Tile Y position in grid (0-based)
 * @param int $tilesX Total tiles in X direction
 * @param int $tilesY Total tiles in Y direction
 * @param float $overlapZone Overlap zone width in inches (default 0.5")
 */
function addDiagonalAlignmentLines($pdf, $pageWidth, $pageHeight, $margin, $tileX, $tileY, $tilesX, $tilesY, $overlapZone = 0.5) {
    // Set line style for diagonal alignment lines (thin, dashed, light gray)
    $pdf->SetLineStyle([
        'width' => 0.008, // Very thin line
        'cap' => 'round',
        'join' => 'round',
        'dash' => '1,2', // Dashed pattern: 1pt line, 2pt gap
        'color' => [128, 128, 128] // Medium gray
    ]);

    // Drawable area (inside margins)
    $contentLeft = $margin;
    $contentRight = $pageWidth - $margin;
    $contentTop = $margin;
    $contentBottom = $pageHeight - $margin;

    // Number of diagonal lines to draw in each overlap zone
    $numLines = 3;

    // -------------------------------------------------------------------------
    // RIGHT EDGE: Diagonal lines if not last column
    // -------------------------------------------------------------------------
    if ($tileX < $tilesX - 1) {
        $overlapStart = $contentRight - $overlapZone;
        $overlapEnd = $contentRight;

        for ($i = 0; $i < $numLines; $i++) {
            // Evenly space diagonal lines across the overlap zone
            $spacing = $overlapZone / ($numLines + 1);
            $xPos = $overlapStart + ($i + 1) * $spacing;

            // Draw diagonal line from top to bottom
            // Angle: 45 degrees (going from top-left to bottom-right of overlap zone)
            $lineLength = min($contentBottom - $contentTop, $overlapZone);
            $pdf->Line($xPos, $contentTop, $xPos + $lineLength * 0.3, $contentTop + $lineLength);
        }
    }

    // -------------------------------------------------------------------------
    // BOTTOM EDGE: Diagonal lines if not last row
    // -------------------------------------------------------------------------
    if ($tileY < $tilesY - 1) {
        $overlapStart = $contentBottom - $overlapZone;
        $overlapEnd = $contentBottom;

        for ($i = 0; $i < $numLines; $i++) {
            // Evenly space diagonal lines across the overlap zone
            $spacing = $overlapZone / ($numLines + 1);
            $yPos = $overlapStart + ($i + 1) * $spacing;

            // Draw diagonal line from left to right
            // Angle: 45 degrees (going from top-left to bottom-right of overlap zone)
            $lineLength = min($contentRight - $contentLeft, $overlapZone);
            $pdf->Line($contentLeft, $yPos, $contentLeft + $lineLength, $yPos + $lineLength * 0.3);
        }
    }

    // Reset line style to solid black
    $pdf->SetLineStyle([
        'width' => 0.012,
        'cap' => 'round',
        'join' => 'round',
        'dash' => 0,
        'color' => [0, 0, 0]
    ]);
}

/**
 * Calculate tile grid for pattern tiling
 * Returns tiling info and whether landscape orientation should be used
 */
function calculateTileGrid($patternWidth, $patternHeight, $paperPortrait, $paperLandscape, $margin) {
    // First try portrait orientation
    $usableWidthP = $paperPortrait['width'] - (2 * $margin);
    $usableHeightP = $paperPortrait['height'] - (2 * $margin); // No extra space needed - tile reference is tiny

    // Check if pattern fits in portrait (single page)
    if ($patternWidth <= $usableWidthP && $patternHeight <= $usableHeightP) {
        // Fits in portrait single page - use portrait orientation
        return [
            'orientation' => 'P',
            'paper' => $paperPortrait,
            'tilesX' => 1,
            'tilesY' => 1,
            'totalTiles' => 1,
            'usableWidth' => $usableWidthP,
            'usableHeight' => $usableHeightP
        ];
    }

    // Pattern doesn't fit in portrait single page
    // Try portrait tiling if width fits (only need vertical tiles)
    if ($patternWidth <= $usableWidthP) {
        // Width fits in portrait, only tile vertically
        $tilesX = 1;
        $tilesY = (int)ceil($patternHeight / $usableHeightP);

        return [
            'orientation' => 'P',
            'paper' => $paperPortrait,
            'tilesX' => $tilesX,
            'tilesY' => $tilesY,
            'totalTiles' => $tilesX * $tilesY,
            'usableWidth' => $usableWidthP,
            'usableHeight' => $usableHeightP
        ];
    }

    // Pattern width doesn't fit in portrait - switch to landscape for tiling
    $usableWidthL = $paperLandscape['width'] - (2 * $margin);
    $usableHeightL = $paperLandscape['height'] - (2 * $margin); // No extra space needed - tile reference is tiny

    $tilesX = (int)ceil($patternWidth / $usableWidthL);
    $tilesY = (int)ceil($patternHeight / $usableHeightL);

    return [
        'orientation' => 'L',
        'paper' => $paperLandscape,
        'tilesX' => $tilesX,
        'tilesY' => $tilesY,
        'totalTiles' => $tilesX * $tilesY,
        'usableWidth' => $usableWidthL,
        'usableHeight' => $usableHeightL
    ];
}

/**
 * Get pattern dimensions from SVG content
 * NOTE: Now that sariBlouse.php sets correct viewBox with tight-fitted dimensions,
 * we can simply read the viewBox directly without needing to parse SVG content.
 */
function getSVGDimensions($svgContent, $scale, $useActualBounds = false) {
    // IMPORTANT: Extract from viewBox (not width/height attributes)
    // The width/height attributes include viewScale (2.0x for display)
    // The viewBox has the correct 1:1 inch scale and is tight-fitted to pattern content
    $svgWidth = null;
    $svgHeight = null;

    // PRIORITY 1: Extract from viewBox (has correct 1:1 scale, tight-fitted by sariBlouse.php)
    if (preg_match('/viewBox="[0-9.]+ [0-9.]+ ([0-9.]+) ([0-9.]+)"/', $svgContent, $viewBoxMatch)) {
        $svgWidth = floatval($viewBoxMatch[1]) / $scale;
        $svgHeight = floatval($viewBoxMatch[2]) / $scale;
    }
    // FALLBACK: Extract from width/height attributes (but these have viewScale applied)
    elseif (preg_match('/width="([0-9.]+)"/', $svgContent, $widthMatch) &&
            preg_match('/height="([0-9.]+)"/', $svgContent, $heightMatch)) {
        // Note: width/height attributes have viewScale (2.0x) baked in, so divide by viewScale
        $viewScale = 2.0; // From sariBlouse.php line 930
        $svgWidth = floatval($widthMatch[1]) / ($scale * $viewScale);
        $svgHeight = floatval($heightMatch[1]) / ($scale * $viewScale);
    }

    // Return SVG dimensions (viewBox is already tight-fitted by sariBlouse.php)
    if ($svgWidth && $svgHeight) {
        return [
            'width' => $svgWidth,
            'height' => $svgHeight,
            'svgWidth' => $svgWidth,      // Keep for backward compatibility
            'svgHeight' => $svgHeight
        ];
    }

    // Default fallback
    return ['width' => 10.0, 'height' => 10.0];
}

/**
 * Calculate the actual bounding box of pattern content in SVG
 * Returns the dimensions of the actual drawn content, not the canvas
 */
function calculateSVGBoundingBox($svgContent, $scale) {
    // Extract all path data and calculate bounds
    $minX = PHP_FLOAT_MAX;
    $minY = PHP_FLOAT_MAX;
    $maxX = PHP_FLOAT_MIN;
    $maxY = PHP_FLOAT_MIN;

    // Match all path elements with their d attribute
    // EXCLUDE paths with stroke="#eee" or stroke-dasharray (reference elements)
    if (preg_match_all('/<path([^>]+)d="([^"]+)"[^>]*>/', $svgContent, $pathFullMatches, PREG_SET_ORDER)) {
        foreach ($pathFullMatches as $pathFull) {
            $pathAttrs = $pathFull[1];
            $pathData = $pathFull[2];

            // Skip if this is a reference element (has stroke="#eee" or stroke-dasharray)
            if (strpos($pathAttrs, 'stroke="#eee"') !== false ||
                strpos($pathAttrs, "stroke='#eee'") !== false ||
                strpos($pathAttrs, 'stroke-dasharray') !== false) {
                continue;
            }

            // Extract all coordinate pairs from the path (M, L, C, Q commands)
            // This is a simplified extraction - gets numbers that look like coordinates
            preg_match_all('/([0-9.]+)\s+([0-9.]+)/', $pathData, $coordMatches, PREG_SET_ORDER);

            foreach ($coordMatches as $coord) {
                $x = floatval($coord[1]);
                $y = floatval($coord[2]);

                $minX = min($minX, $x);
                $minY = min($minY, $y);
                $maxX = max($maxX, $x);
                $maxY = max($maxY, $y);
            }
        }
    }

    // Check rect elements (EXCLUDE reference grid lines with stroke="#eee")
    if (preg_match_all('/<rect([^>]+)>/', $svgContent, $rectFullMatches, PREG_SET_ORDER)) {
        foreach ($rectFullMatches as $rectFull) {
            $rectAttrs = $rectFull[1];

            // Skip if this is a reference grid element (has stroke="#eee")
            if (strpos($rectAttrs, 'stroke="#eee"') !== false || strpos($rectAttrs, "stroke='#eee'") !== false) {
                continue;
            }

            // Extract x, y, width, height
            if (preg_match('/x="([0-9.]+)"/', $rectAttrs, $xMatch) &&
                preg_match('/y="([0-9.]+)"/', $rectAttrs, $yMatch) &&
                preg_match('/width="([0-9.]+)"/', $rectAttrs, $wMatch) &&
                preg_match('/height="([0-9.]+)"/', $rectAttrs, $hMatch)) {

                $x = floatval($xMatch[1]);
                $y = floatval($yMatch[1]);
                $w = floatval($wMatch[1]);
                $h = floatval($hMatch[1]);

                $minX = min($minX, $x);
                $minY = min($minY, $y);
                $maxX = max($maxX, $x + $w);
                $maxY = max($maxY, $y + $h);
            }
        }
    }

    // EXCLUDE line elements with stroke="#eee" (reference grid lines)
    // These are the origin grid lines that span the entire canvas
    // We skip them entirely - they should not affect the bounding box
    // (Already excluded by not processing <line> elements)

    // Also check line elements (but EXCLUDE grid lines with stroke="#eee")
    if (preg_match_all('/<line([^>]+)>/', $svgContent, $lineFullMatches, PREG_SET_ORDER)) {
        foreach ($lineFullMatches as $lineFull) {
            $lineAttrs = $lineFull[1];

            // Skip if this is a reference grid line (has stroke="#eee" or stroke-dasharray)
            if (strpos($lineAttrs, 'stroke="#eee"') !== false ||
                strpos($lineAttrs, "stroke='#eee'") !== false ||
                strpos($lineAttrs, 'stroke-dasharray') !== false) {
                continue;
            }

            // Extract x1, y1, x2, y2 for lines (like snip-triangle lines)
            if (preg_match('/x1="([0-9.]+)"/', $lineAttrs, $x1Match) &&
                preg_match('/y1="([0-9.]+)"/', $lineAttrs, $y1Match) &&
                preg_match('/x2="([0-9.]+)"/', $lineAttrs, $x2Match) &&
                preg_match('/y2="([0-9.]+)"/', $lineAttrs, $y2Match)) {

                $x1 = floatval($x1Match[1]);
                $y1 = floatval($y1Match[1]);
                $x2 = floatval($x2Match[1]);
                $y2 = floatval($y2Match[1]);

                $minX = min($minX, $x1, $x2);
                $minY = min($minY, $y1, $y2);
                $maxX = max($maxX, $x1, $x2);
                $maxY = max($maxY, $y1, $y2);
            }
        }
    }

    // If we found valid bounds
    if ($minX != PHP_FLOAT_MAX && $maxX != PHP_FLOAT_MIN) {
        $width = ($maxX - $minX) / $scale;
        $height = ($maxY - $minY) / $scale;

        return [
            'width' => $width,
            'height' => $height,
            'minX' => $minX,
            'minY' => $minY,
            'maxX' => $maxX,
            'maxY' => $maxY
        ];
    }

    return null;
}

/**
 * Validate scale box size mathematically
 * Checks if the rendering parameters will produce correct 2" × 2" scale box
 */
function validateScaleMathematically($svgContent, $scale, $renderScale = 1.0) {
    echo "\n<strong>MATHEMATICAL SCALE VALIDATION:</strong>\n";

    // Step 1: Extract viewBox from SVG
    if (!preg_match('/viewBox="([0-9.]+) ([0-9.]+) ([0-9.]+) ([0-9.]+)"/', $svgContent, $viewBoxMatch)) {
        echo "  ❌ ERROR: Could not extract viewBox from SVG\n";
        return false;
    }

    $viewBoxWidth = floatval($viewBoxMatch[3]);
    $viewBoxHeight = floatval($viewBoxMatch[4]);

    echo "  SVG viewBox dimensions: {$viewBoxWidth}px × {$viewBoxHeight}px\n";

    // Step 2: Calculate SVG dimensions in inches (at 1:1 scale)
    $svgWidthInches = $viewBoxWidth / $scale;
    $svgHeightInches = $viewBoxHeight / $scale;

    echo "  SVG dimensions (1:1): " . number_format($svgWidthInches, 2) . "\" × " . number_format($svgHeightInches, 2) . "\"\n";

    // Step 3: Calculate rendered dimensions
    $renderedWidthInches = $svgWidthInches * $renderScale;
    $renderedHeightInches = $svgHeightInches * $renderScale;

    echo "  Rendered dimensions ({$renderScale}x): " . number_format($renderedWidthInches, 2) . "\" × " . number_format($renderedHeightInches, 2) . "\"\n";

    // Step 4: Calculate scale box transformation
    // Scale box in SVG: 50.8px × 50.8px (2" × 2" at 25.4 px/in)
    $scaleBoxSVGPixels = 2.0 * $scale; // 50.8px
    $scaleBoxSVGInches = 2.0; // 2"

    echo "  Scale box in SVG: {$scaleBoxSVGPixels}px = {$scaleBoxSVGInches}\"\n";

    // When SVG is rendered at renderScale, the scale box becomes:
    $scaleBoxRenderedInches = $scaleBoxSVGInches * $renderScale;

    echo "  Scale box after rendering: " . number_format($scaleBoxRenderedInches, 2) . "\" × " . number_format($scaleBoxRenderedInches, 2) . "\"\n";

    // Step 5: Check if it matches expected size
    $expectedSize = 2.0 * $renderScale;
    $tolerance = 0.05; // ±0.05"

    $error = abs($scaleBoxRenderedInches - $expectedSize);

    echo "  Expected size: " . number_format($expectedSize, 2) . "\" × " . number_format($expectedSize, 2) . "\"\n";
    echo "  Error: " . number_format($error, 3) . "\"\n";

    if ($error < $tolerance) {
        echo "  ✅ PASS: Scale is correct (error < {$tolerance}\")\n";
        return true;
    } else {
        echo "  ❌ FAIL: Scale is INCORRECT (error = " . number_format($error, 3) . "\")\n";
        echo "\n<strong>DIAGNOSIS:</strong>\n";

        // Suggest fix
        $correctRenderScale = $expectedSize / $scaleBoxSVGInches;
        echo "  Current render scale: {$renderScale}x\n";
        echo "  Correct render scale should be: " . number_format($correctRenderScale, 2) . "x\n";

        // Additional diagnostics
        echo "\n<strong>POSSIBLE CAUSES:</strong>\n";
        echo "  1. ViewBox doesn't match expected 1:1 inch scale (should be at 25.4 px/in)\n";
        echo "  2. Render scale is incorrect\n";
        echo "  3. SVG was generated with wrong scale factor\n";

        return false;
    }
}

/**
 * Modify SVG viewBox for tiling
 */
function modifySVGForTile($svgContent, $tileOffsetX, $tileOffsetY, $tileWidth, $tileHeight, $scale) {
    // Calculate viewBox coordinates in pixels
    $viewBoxX = $tileOffsetX * $scale;
    $viewBoxY = $tileOffsetY * $scale;
    $viewBoxWidth = $tileWidth * $scale;
    $viewBoxHeight = $tileHeight * $scale;

    // Create new viewBox attribute
    $newViewBox = sprintf('viewBox="%.2f %.2f %.2f %.2f"', $viewBoxX, $viewBoxY, $viewBoxWidth, $viewBoxHeight);

    // Replace existing viewBox or add if not present
    if (preg_match('/viewBox="[^"]*"/', $svgContent)) {
        $modifiedSVG = preg_replace('/viewBox="[^"]*"/', $newViewBox, $svgContent);
    } else {
        $modifiedSVG = preg_replace('/<svg/', '<svg ' . $newViewBox, $svgContent, 1);
    }

    return $modifiedSVG;
}

/**
 * Generate Summary Sheet as the first page of the PDF
 * Contains: Logo, Title, Customer Details, Measurements, Pattern Thumbnails, Disclaimer
 *
 * @param object $pdf TCPDF instance
 * @param float $pageWidth Page width in inches
 * @param float $pageHeight Page height in inches
 * @param float $margin Page margin in inches
 * @param array $patternData Pattern data from session
 * @param array $tileInfo Array with tile counts for each pattern
 * @param string $paperSize Paper size name (A3, A4, etc.)
 */
function addSummarySheet($pdf, $pageWidth, $pageHeight, $margin, $patternData, $tileInfo, $paperSize) {
    // Add logo (uses existing function positioning)
    addCMLogo($pdf, $pageWidth, $pageHeight);

    // =========================================================================
    // TITLE SECTION
    // =========================================================================
    $contentStartY = 0.5; // Start content below top margin
    $contentWidth = $pageWidth - (2 * $margin);

    // Title: "SAREE BLOUSE PATTERN"
    $pdf->SetFont('helvetica', 'B', 24);
    $pdf->SetTextColor(0, 51, 102); // Dark blue
    $titleText = 'SAREE BLOUSE PATTERN';
    $titleWidth = $pdf->GetStringWidth($titleText);
    $titleX = $margin; // Left-aligned
    $titleY = $contentStartY;
    $pdf->Text($titleX, $titleY, $titleText);

    // Draw decorative line under title
    $pdf->SetDrawColor(0, 102, 153);
    $pdf->SetLineWidth(0.02);
    $lineY = $titleY + 0.35;
    $pdf->Line($margin, $lineY, $pageWidth - $margin - 4, $lineY); // Leave space for logo

    // =========================================================================
    // CUSTOMER DETAILS SECTION
    // =========================================================================
    $customerY = $lineY + 0.4;
    $pdf->SetFont('helvetica', 'B', 12);
    $pdf->SetTextColor(0, 0, 0);
    $pdf->Text($margin, $customerY, 'CUSTOMER DETAILS');

    // Customer details area (no box)
    $boxY = $customerY + 0.25;
    $boxHeight = 0.5;

    // Customer name and contact
    $pdf->SetFont('helvetica', '', 11);
    $customerName = $patternData['metadata']['customer_name'] ?? 'Unknown';
    $contactNumber = $patternData['metadata']['contact_number'] ?? $patternData['metadata']['mobile_number'] ?? '';

    $pdf->Text($margin + 0.15, $boxY + 0.3, 'Name: ' . $customerName);
    if (!empty($contactNumber)) {
        $pdf->Text($margin + ($contentWidth / 2), $boxY + 0.3, 'Contact: ' . $contactNumber);
    }

    // =========================================================================
    // PRINTING & TILE MATCHING INSTRUCTIONS
    // =========================================================================
    $instructionsY = $boxY + $boxHeight + 0.3;

    $pdf->SetFont('helvetica', 'B', 11);
    $pdf->SetTextColor(0, 0, 0);
    $pdf->Text($margin, $instructionsY, 'PRINTING & ASSEMBLY INSTRUCTIONS');

    // Instructions area (no box)
    $instrBoxY = $instructionsY + 0.22;
    $instrBoxHeight = 0.95;

    // Instructions content
    $pdf->SetFont('helvetica', '', 9);
    $pdf->SetTextColor(50, 50, 50);

    $instructions = [
        '1. Print at 100% scale (no scaling/fit-to-page). Verify using the 1-inch reference square on each tile.',
        '2. Match tiles using registration marks (+) at corners. Align diagonal lines for precise positioning.',
        '3. Overlap tiles at matching marks, then tape securely before cutting the pattern.'
    ];

    $instrTextY = $instrBoxY + 0.18;
    $lineHeight = 0.22;
    foreach ($instructions as $instruction) {
        $pdf->Text($margin + 0.15, $instrTextY, $instruction);
        $instrTextY += $lineHeight;
    }

    // =========================================================================
    // TWO-COLUMN LAYOUT: MEASUREMENTS (Left) & PATTERN TILES (Right)
    // =========================================================================
    $twoColY = $instrBoxY + $instrBoxHeight + 0.3;
    $leftColWidth = ($contentWidth * 0.32); // 32% for measurements (reduced)
    $rightColWidth = ($contentWidth * 0.63); // 63% for thumbnails (increased)
    $colGap = $contentWidth * 0.05; // 5% gap

    // ----- LEFT COLUMN: MEASUREMENTS -----
    $pdf->SetFont('helvetica', 'B', 12);
    $pdf->SetTextColor(0, 0, 0);
    $pdf->Text($margin, $twoColY, 'MEASUREMENTS');

    // Measurements area (no box)
    $measBoxY = $twoColY + 0.25;
    $measBoxHeight = 5.5; // Height for measurements area

    // Measurement values from pattern data
    $measurements = $patternData['measurements'] ?? [];
    $measList = [
        ['label' => 'Bust', 'key' => 'bust'],
        ['label' => 'Chest', 'key' => 'chest'],
        ['label' => 'Waist', 'key' => 'waist'],
        ['label' => 'Shoulder', 'key' => 'shoulder'],
        ['label' => 'Front Shoulder', 'key' => 'fshoulder'],
        ['label' => 'Armhole', 'key' => 'armhole'],
        ['label' => 'F.Neck Depth', 'key' => 'fndepth'],
        ['label' => 'B.Neck Depth', 'key' => 'bnDepth'],
        ['label' => 'Front Length', 'key' => 'flength'],
        ['label' => 'Back Length', 'key' => 'blength'],
        ['label' => 'Apex', 'key' => 'apex'],
        ['label' => 'Sleeve Length', 'key' => 'slength'],
        ['label' => 'Sleeve Round', 'key' => 'saround'],
        ['label' => 'Sleeve Open', 'key' => 'sopen'],
    ];

    $pdf->SetFont('helvetica', '', 9);
    $measY = $measBoxY + 0.3;
    $lineHeight = 0.35;

    foreach ($measList as $meas) {
        $value = $measurements[$meas['key']] ?? '';
        if ($value !== '') {
            $pdf->Text($margin + 0.1, $measY, $meas['label'] . ':');
            $pdf->Text($margin + 1.1, $measY, number_format((float)$value, 2) . '"');
            $measY += $lineHeight;
        }
    }

    // ----- RIGHT COLUMN: PATTERN TILES ASSEMBLY GUIDE -----
    $rightColX = $margin + $leftColWidth + $colGap;
    $pdf->SetFont('helvetica', 'B', 12);
    $pdf->SetTextColor(0, 0, 0);
    $pdf->Text($rightColX, $twoColY, 'PATTERN TILES ASSEMBLY GUIDE');

    // Tiles area (no box)
    $tilesBoxY = $twoColY + 0.25;
    $tilesBoxHeight = $measBoxHeight; // Same height as measurements

    // Calculate thumbnail size (increased for better visibility)
    $thumbMaxWidth = 2.5;   // Max width of each thumbnail
    $thumbMaxHeight = 2.2;  // Max height of each thumbnail
    $thumbGap = 0.35;       // Gap between thumbnails
    $thumbStartY = $tilesBoxY + 0.35;
    $thumbStartX = $rightColX + 0.15;

    // Pattern thumbnails with tile breakup - now with proper aspect ratio
    $patterns = [
        ['name' => '1. FRONT', 'key' => 'front', 'svg' => $patternData['front']['svg_content'] ?? null],
        ['name' => '2. BACK', 'key' => 'back', 'svg' => $patternData['back']['svg_content'] ?? null],
        ['name' => '3. PATTI', 'key' => 'patti', 'svg' => $patternData['patti']['svg_content'] ?? null],
        ['name' => '4. SLEEVE', 'key' => 'sleeve', 'svg' => $patternData['sleeve']['svg_content'] ?? null],
    ];

    $thumbX = $thumbStartX;
    $thumbY = $thumbStartY;
    $thumbsPerRow = 2;
    $thumbCount = 0;
    $totalPages = 0;

    // Scale factor for SVG units (25.4 px/in)
    $svgScale = 25.4;

    foreach ($patterns as $pattern) {
        if ($pattern['svg']) {
            // Get actual SVG dimensions from viewBox to maintain aspect ratio
            $svgWidth = $thumbMaxWidth;
            $svgHeight = $thumbMaxHeight;
            $patternWidth = 0;
            $patternHeight = 0;

            // Extract viewBox dimensions
            if (preg_match('/viewBox="[0-9.]+ [0-9.]+ ([0-9.]+) ([0-9.]+)"/', $pattern['svg'], $vbMatch)) {
                $patternWidth = floatval($vbMatch[1]) / $svgScale;  // Convert to inches
                $patternHeight = floatval($vbMatch[2]) / $svgScale;

                // Calculate thumbnail size maintaining aspect ratio
                $aspectRatio = $patternWidth / $patternHeight;

                if ($aspectRatio > ($thumbMaxWidth / $thumbMaxHeight)) {
                    // Pattern is wider - fit to width
                    $svgWidth = $thumbMaxWidth;
                    $svgHeight = $thumbMaxWidth / $aspectRatio;
                } else {
                    // Pattern is taller - fit to height
                    $svgHeight = $thumbMaxHeight;
                    $svgWidth = $thumbMaxHeight * $aspectRatio;
                }
            }

            // Draw thumbnail label
            $pdf->SetFont('helvetica', 'B', 9);
            $pdf->SetTextColor(0, 0, 0);
            $pdf->Text($thumbX, $thumbY, $pattern['name']);

            // Draw thumbnail border (sized to actual SVG)
            $pdf->SetDrawColor(150, 150, 150);
            $pdf->SetLineWidth(0.01);
            $thumbBoxY = $thumbY + 0.18;
            $pdf->Rect($thumbX, $thumbBoxY, $svgWidth, $svgHeight, 'D');

            // Render miniature SVG (maintaining aspect ratio)
            $pdf->ImageSVG('@' . $pattern['svg'], $thumbX, $thumbBoxY,
                          $svgWidth, $svgHeight, '', '', '', 0, false);

            // Draw tile grid overlay based on ACTUAL tile dimensions
            $tiles = $tileInfo[$pattern['key']] ?? ['tilesX' => 1, 'tilesY' => 1, 'totalTiles' => 1];
            if ($tiles['totalTiles'] > 1 && $patternWidth > 0 && $patternHeight > 0) {
                $pdf->SetDrawColor(255, 0, 0); // Red dashed lines for tile breaks
                $pdf->SetLineStyle(['width' => 0.02, 'dash' => '3,2']);

                // Calculate actual tile dimensions based on usable paper area
                // For A3: usable area is approximately 11.09" x 15.94" (portrait)
                // The tileInfo tells us how many tiles, we calculate proportional lines

                // Vertical tile lines (based on tilesX)
                if ($tiles['tilesX'] > 1) {
                    // Each tile covers 1/tilesX of the pattern width
                    for ($i = 1; $i < $tiles['tilesX']; $i++) {
                        $lineX = $thumbX + ($svgWidth * $i / $tiles['tilesX']);
                        $pdf->Line($lineX, $thumbBoxY, $lineX, $thumbBoxY + $svgHeight);
                    }
                }

                // Horizontal tile lines (based on tilesY)
                if ($tiles['tilesY'] > 1) {
                    // Each tile covers 1/tilesY of the pattern height
                    for ($i = 1; $i < $tiles['tilesY']; $i++) {
                        $tileLineY = $thumbBoxY + ($svgHeight * $i / $tiles['tilesY']);
                        $pdf->Line($thumbX, $tileLineY, $thumbX + $svgWidth, $tileLineY);
                    }
                }

                // Reset line style
                $pdf->SetLineStyle(['width' => 0.01, 'dash' => 0]);
                $pdf->SetDrawColor(0, 0, 0);
            }

            // Tile count label
            $pdf->SetFont('helvetica', '', 8);
            $pdf->SetTextColor(80, 80, 80);
            $tileLabel = $tiles['totalTiles'] == 1 ? '(1 page)' : '(' . $tiles['totalTiles'] . ' tiles: ' . $tiles['tilesX'] . '×' . $tiles['tilesY'] . ')';
            $pdf->Text($thumbX, $thumbBoxY + $svgHeight + 0.15, $tileLabel);
            $pdf->SetTextColor(0, 0, 0);

            $totalPages += $tiles['totalTiles'];

            // Move to next position (use max dimensions for consistent spacing)
            $thumbCount++;
            if ($thumbCount % $thumbsPerRow == 0) {
                $thumbX = $thumbStartX;
                $thumbY += $thumbMaxHeight + 0.55;
            } else {
                $thumbX += $thumbMaxWidth + $thumbGap;
            }
        }
    }

    // Total pages summary
    $pdf->SetFont('helvetica', 'B', 10);
    $summaryY = $tilesBoxY + $tilesBoxHeight - 0.4;
    $pdf->Text($rightColX + 0.15, $summaryY, 'Total Pattern Pages: ' . $totalPages);

    // =========================================================================
    // DISCLAIMER SECTION
    // =========================================================================
    $disclaimerY = $measBoxY + $measBoxHeight + 0.4;
    $pdf->SetFont('helvetica', 'B', 11);
    $pdf->SetTextColor(0, 0, 0);
    $pdf->Text($margin, $disclaimerY, 'DISCLAIMER');

    // Disclaimer area (no box)
    $discBoxY = $disclaimerY + 0.2;
    $discBoxHeight = 1.2;

    // Disclaimer text
    $pdf->SetFont('helvetica', '', 9);
    $discTextY = $discBoxY + 0.25;
    $discLineHeight = 0.22;

    $disclaimerLines = [
        '• This pattern is generated based on the measurements provided.',
        '• Please verify all measurements before cutting fabric.',
        '• Seam allowance is NOT included - add as per your requirement.',
        '• Print at 100% scale (Actual Size) - verify with 2" × 2" scale box on pattern pages.',
        '• CuttingMaster.in is not responsible for errors due to incorrect measurements or improper assembly.',
    ];

    foreach ($disclaimerLines as $line) {
        $pdf->Text($margin + 0.15, $discTextY, $line);
        $discTextY += $discLineHeight;
    }

    // =========================================================================
    // FOOTER SECTION
    // =========================================================================
    $footerY = $pageHeight - $margin - 0.3;
    $pdf->SetFont('helvetica', '', 9);
    $pdf->SetTextColor(100, 100, 100);

    // Left side: Generation info
    $generatedDate = date('d-M-Y h:i A');
    $pdf->Text($margin, $footerY, 'Generated: ' . $generatedDate);

    $patternId = $patternData['metadata']['measurement_id'] ?? 'N/A';
    $pdf->Text($margin, $footerY + 0.2, 'Pattern ID: ' . $patternId);

    // Right side: Paper info
    $pdf->Text($pageWidth - $margin - 2.5, $footerY, 'Paper Size: ' . $paperSize);
    $pdf->Text($pageWidth - $margin - 2.5, $footerY + 0.2, 'Scale: 1:1 (Actual Size)');

    // Reset text color
    $pdf->SetTextColor(0, 0, 0);
}

// =============================================================================
// CREATE PDF
// =============================================================================

// Initialize PDF with default portrait orientation (will add pages dynamically with correct orientation)
$pdf = new TCPDF('P', 'in', [$paper['width'], $paper['height']], true, 'UTF-8', false);

$pdf->SetCreator('CM-2025 Pattern Generator');
$pdf->SetAuthor($customerName);
$pdf->SetTitle('Saree Blouse Pattern - ' . $customerName);
$pdf->setPrintHeader(false);
$pdf->setPrintFooter(false);
$pdf->SetMargins($margin, $margin, $margin);
$pdf->SetAutoPageBreak(false, $margin);
$pdf->SetFont('helvetica', '', 10);
$pdf->SetTextColor(0, 0, 0);

// Pattern starts at left and top margins
$startX = $margin;
$startY = $margin;

// Note: Scale box (2" x 2") is already embedded in the SVG from sariBlouse.php
// No need to add it separately in the PDF

// =============================================================================
// PRE-CALCULATE TILE INFO FOR ALL PATTERNS (needed for Summary Sheet)
// =============================================================================
$tileInfo = [];

// Front pattern tile info
if (isset($patternData['front']['svg_content'])) {
    $frontSVGTemp = $patternData['front']['svg_content'];
    $frontDimsTemp = getSVGDimensions($frontSVGTemp, $scale);
    $frontTileGridTemp = calculateTileGrid($frontDimsTemp['width'], $frontDimsTemp['height'],
                                          $paperSizes[$paperSize]['portrait'],
                                          $paperSizes[$paperSize]['landscape'], $margin);
    $tileInfo['front'] = [
        'tilesX' => $frontTileGridTemp['tilesX'],
        'tilesY' => $frontTileGridTemp['tilesY'],
        'totalTiles' => $frontTileGridTemp['totalTiles']
    ];
}

// Back pattern tile info
if (isset($patternData['back']['svg_content'])) {
    $backSVGTemp = $patternData['back']['svg_content'];
    $backDimsTemp = getSVGDimensions($backSVGTemp, $scale);
    $backTileGridTemp = calculateTileGrid($backDimsTemp['width'], $backDimsTemp['height'],
                                         $paperSizes[$paperSize]['portrait'],
                                         $paperSizes[$paperSize]['landscape'], $margin);
    $tileInfo['back'] = [
        'tilesX' => $backTileGridTemp['tilesX'],
        'tilesY' => $backTileGridTemp['tilesY'],
        'totalTiles' => $backTileGridTemp['totalTiles']
    ];
}

// Patti pattern tile info
if (isset($patternData['patti']['svg_content'])) {
    $pattiSVGTemp = $patternData['patti']['svg_content'];
    $pattiDimsTemp = getSVGDimensions($pattiSVGTemp, $scale);
    $pattiTileGridTemp = calculateTileGrid($pattiDimsTemp['width'], $pattiDimsTemp['height'],
                                          $paperSizes[$paperSize]['portrait'],
                                          $paperSizes[$paperSize]['landscape'], $margin);
    $tileInfo['patti'] = [
        'tilesX' => $pattiTileGridTemp['tilesX'],
        'tilesY' => $pattiTileGridTemp['tilesY'],
        'totalTiles' => $pattiTileGridTemp['totalTiles']
    ];
}

// Sleeve pattern tile info
if (isset($patternData['sleeve']['svg_content'])) {
    $sleeveSVGTemp = $patternData['sleeve']['svg_content'];
    $sleeveDimsTemp = getSVGDimensions($sleeveSVGTemp, $scale);
    $sleeveTileGridTemp = calculateTileGrid($sleeveDimsTemp['width'], $sleeveDimsTemp['height'],
                                           $paperSizes[$paperSize]['portrait'],
                                           $paperSizes[$paperSize]['landscape'], $margin);
    $tileInfo['sleeve'] = [
        'tilesX' => $sleeveTileGridTemp['tilesX'],
        'tilesY' => $sleeveTileGridTemp['tilesY'],
        'totalTiles' => $sleeveTileGridTemp['totalTiles']
    ];
}

// =============================================================================
// SUMMARY SHEET (Page 1)
// =============================================================================
$pdf->AddPage('P', [$paper['width'], $paper['height']]);
addSummarySheet($pdf, $paper['width'], $paper['height'], $margin, $patternData, $tileInfo, $paperSize);

// =============================================================================
// DEBUG: Show all 4 patterns at once
// =============================================================================
/*
// Pre-calculate dimensions for all patterns
$frontSVG = $patternData['front']['svg_content'] ?? null;
$backSVG = $patternData['back']['svg_content'] ?? null;
$pattiSVG = $patternData['patti']['svg_content'] ?? null;
$sleeveSVG = $patternData['sleeve']['svg_content'] ?? null;

$frontDims = $frontSVG ? getSVGDimensions($frontSVG, $scale) : null;
$backDims = $backSVG ? getSVGDimensions($backSVG, $scale) : null;
$pattiDims = $pattiSVG ? getSVGDimensions($pattiSVG, $scale) : null;
$sleeveDims = $sleeveSVG ? getSVGDimensions($sleeveSVG, $scale) : null;

echo "<pre style='background: #f0f0f0; padding: 20px; margin: 20px; border: 2px solid #333;'>";
echo "<h2>ALL PATTERNS BOUNDING BOX VERIFICATION</h2>\n";
echo "Paper: A3, Scale: 25.4 px/in\n\n";

if ($frontDims) {
    echo "1. FRONT PATTERN:\n";
    echo "   ViewBox dimensions: " . number_format($frontDims['width'], 2) . "\" × " . number_format($frontDims['height'], 2) . "\"\n";
    $frontTiles = calculateTileGrid($frontDims['width'], $frontDims['height'],
                                   $paperSizes[$paperSize]['portrait'],
                                   $paperSizes[$paperSize]['landscape'], $margin);
    echo "   Tiles needed: {$frontTiles['totalTiles']} ({$frontTiles['tilesX']}×{$frontTiles['tilesY']}, " .
         ($frontTiles['orientation'] == 'P' ? 'Portrait' : 'Landscape') . ")\n\n";
}

if ($backDims) {
    echo "2. BACK PATTERN:\n";
    echo "   ViewBox dimensions: " . number_format($backDims['width'], 2) . "\" × " . number_format($backDims['height'], 2) . "\"\n";
    $backTiles = calculateTileGrid($backDims['width'], $backDims['height'],
                                  $paperSizes[$paperSize]['portrait'],
                                  $paperSizes[$paperSize]['landscape'], $margin);
    echo "   Tiles needed: {$backTiles['totalTiles']} ({$backTiles['tilesX']}×{$backTiles['tilesY']}, " .
         ($backTiles['orientation'] == 'P' ? 'Portrait' : 'Landscape') . ")\n\n";
}

if ($pattiDims) {
    echo "3. PATTI PATTERN:\n";
    echo "   ViewBox dimensions: " . number_format($pattiDims['width'], 2) . "\" × " . number_format($pattiDims['height'], 2) . "\"\n";
    $pattiTiles = calculateTileGrid($pattiDims['width'], $pattiDims['height'],
                                   $paperSizes[$paperSize]['portrait'],
                                   $paperSizes[$paperSize]['landscape'], $margin);
    echo "   Tiles needed: {$pattiTiles['totalTiles']} ({$pattiTiles['tilesX']}×{$pattiTiles['tilesY']}, " .
         ($pattiTiles['orientation'] == 'P' ? 'Portrait' : 'Landscape') . ")\n\n";
}

if ($sleeveDims) {
    echo "4. SLEEVE PATTERN:\n";
    echo "   ViewBox dimensions: " . number_format($sleeveDims['width'], 2) . "\" × " . number_format($sleeveDims['height'], 2) . "\"\n";
    $sleeveTiles = calculateTileGrid($sleeveDims['width'], $sleeveDims['height'],
                                    $paperSizes[$paperSize]['portrait'],
                                    $paperSizes[$paperSize]['landscape'], $margin);
    echo "   Tiles needed: {$sleeveTiles['totalTiles']} ({$sleeveTiles['tilesX']}×{$sleeveTiles['tilesY']}, " .
         ($sleeveTiles['orientation'] == 'P' ? 'Portrait' : 'Landscape') . ")\n\n";
}

echo "</pre>";
exit;
*/

// =============================================================================
// PATTERN 1: FRONT
// =============================================================================

if (isset($patternData['front']['svg_content'])) {
    $frontSVG = $patternData['front']['svg_content'];
    $frontDims = getSVGDimensions($frontSVG, $scale);
    $frontTileGrid = calculateTileGrid($frontDims['width'], $frontDims['height'],
                                      $paperSizes[$paperSize]['portrait'],
                                      $paperSizes[$paperSize]['landscape'],
                                      $margin);

    // Calculate paper size for debug output
    $frontPaper = $frontTileGrid['paper'];
    $frontOrientation = $frontTileGrid['orientation'];

    // =============================================================================
    // DEBUG OUTPUT: Show tiling calculations for Front pattern
    // =============================================================================
    /*
    echo "<pre style='background: #f0f0f0; padding: 20px; margin: 20px; border: 2px solid #333;'>";
    echo "<h3>FRONT PATTERN DEBUG</h3>";

    // VALIDATE SCALE BEFORE GENERATING PDF
    $renderScale = 1.0; // Current render scale (1:1 for testing, will be 4:1 for production)
    $scaleValid = validateScaleMathematically($frontSVG, $scale, $renderScale);

    if (!$scaleValid) {
        echo "\n<strong style='color: red;'>⚠️  WARNING: Scale validation failed!</strong>\n";
        echo "PDF generation paused. Please review the scale settings above.\n";
        echo "\nTo proceed anyway, comment out the validation or fix the scale issue.\n";
        echo "</pre>";
        exit;
    }

    echo "\n<strong>PATTERN DIMENSIONS:</strong>\n";
    echo "  Calculated pattern bounds: {$frontDims['width']}\" × {$frontDims['height']}\"\n";
    if (isset($frontDims['svgWidth']) && isset($frontDims['svgHeight'])) {
        echo "  SVG canvas/viewBox size: {$frontDims['svgWidth']}\" × {$frontDims['svgHeight']}\"\n";

        // Check if bounding box is larger than SVG canvas
        if ($frontDims['width'] > $frontDims['svgWidth'] || $frontDims['height'] > $frontDims['svgHeight']) {
            echo "  ⚠️  WARNING: Bounding box is LARGER than SVG canvas!\n";
            echo "     This means some elements are being included that shouldn't be.\n";
            echo "  → IGNORING bounding box, using SVG canvas dimensions instead\n";
            // Override with SVG canvas dimensions
            $frontDims['width'] = $frontDims['svgWidth'];
            $frontDims['height'] = $frontDims['svgHeight'];
        } else {
            echo "  → Using actual bounds (smaller) for tiling\n";
        }
    }
    if (isset($frontDims['offsetX']) && isset($frontDims['offsetY'])) {
        echo "  Pattern offset in SVG: ({$frontDims['offsetX']}\", {$frontDims['offsetY']}\")\n";
    }

    // Show what will be rendered
    $svgWidth = isset($frontDims['svgWidth']) ? $frontDims['svgWidth'] : $frontDims['width'];
    $svgHeight = isset($frontDims['svgHeight']) ? $frontDims['svgHeight'] : $frontDims['height'];
    $renderWidth = $svgWidth * 4.0;
    $renderHeight = $svgHeight * 4.0;
    echo "\n<strong>RENDERING DIMENSIONS (at 4x scale):</strong>\n";
    echo "  SVG canvas: {$svgWidth}\" × {$svgHeight}\"\n";
    echo "  Render size: {$renderWidth}\" × {$renderHeight}\" (4x scale)\n";
    echo "  Paper size: {$frontPaper['width']}\" × {$frontPaper['height']}\"\n";
    echo "  Will it fit? Width: " . ($renderWidth <= $frontPaper['width'] ? 'YES' : 'NO') . ", Height: " . ($renderHeight <= $frontPaper['height'] ? 'YES' : 'NO') . "\n";
    echo "\n<strong>PAPER CONFIGURATION:</strong>\n";
    echo "Paper selected: $paperSize\n";
    echo "Paper (portrait): {$paperSizes[$paperSize]['portrait']['width']}\" × {$paperSizes[$paperSize]['portrait']['height']}\"\n";
    echo "Paper (landscape): {$paperSizes[$paperSize]['landscape']['width']}\" × {$paperSizes[$paperSize]['landscape']['height']}\"\n";

    echo "\n<strong>TILING DECISION:</strong>\n";
    if ($frontTileGrid['orientation'] == 'P') {
        echo "Usable area (portrait): {$frontTileGrid['usableWidth']}\" × {$frontTileGrid['usableHeight']}\" (with margin: $margin\")\n";
    } else {
        echo "Usable area (landscape): {$frontTileGrid['usableWidth']}\" × {$frontTileGrid['usableHeight']}\" (with margin: $margin\")\n";
    }

    echo "Orientation chosen: " . ($frontTileGrid['orientation'] == 'P' ? 'Portrait' : 'Landscape') . "\n";
    echo "Tiles X: {$frontTileGrid['tilesX']}\n";
    echo "Tiles Y: {$frontTileGrid['tilesY']}\n";
    echo "Total tiles calculated: {$frontTileGrid['totalTiles']}\n";
    echo "\nDoes pattern fit in portrait?\n";

    $portraitUsableW = $paperSizes[$paperSize]['portrait']['width'] - (2 * $margin);
    $portraitUsableH = $paperSizes[$paperSize]['portrait']['height'] - (2 * $margin) - 1.0;

    echo "  Pattern width ({$frontDims['width']}\") <= Portrait usable width ($portraitUsableW\")? " . ($frontDims['width'] <= $portraitUsableW ? 'YES' : 'NO') . "\n";
    echo "  Pattern height ({$frontDims['height']}\") <= Portrait usable height ($portraitUsableH\")? " . ($frontDims['height'] <= $portraitUsableH ? 'YES' : 'NO') . "\n";

    echo "\n<strong>TILE GENERATION SIMULATION:</strong>\n";
    echo "Will generate tiles in this order (showing which will be SKIPPED):\n\n";

    $simulatedTileNum = 1;
    for ($ty = 0; $ty < $frontTileGrid['tilesY']; $ty++) {
        for ($tx = 0; $tx < $frontTileGrid['tilesX']; $tx++) {
            $tileOffsetX = $tx * $frontTileGrid['usableWidth'];
            $tileOffsetY = $ty * $frontTileGrid['usableHeight'];

            $actualTileWidth = min($frontTileGrid['usableWidth'], $frontDims['width'] - $tileOffsetX);
            $actualTileHeight = min($frontTileGrid['usableHeight'], $frontDims['height'] - $tileOffsetY);

            $skipReason = '';
            if ($tileOffsetX >= $frontDims['width'] || $tileOffsetY >= $frontDims['height']) {
                $skipReason = '❌ SKIP: Tile offset outside pattern area';
            } elseif ($actualTileWidth < 0.1 || $actualTileHeight < 0.1) {
                $skipReason = '❌ SKIP: Tile dimensions too small';
            } else {
                $skipReason = "✅ GENERATE (Tile $simulatedTileNum)";
                $simulatedTileNum++;
            }

            echo sprintf("  Grid[%d,%d]: offset=(%5.2f\",%5.2f\"), size=(%5.2f\" × %5.2f\") - %s\n",
                $tx, $ty,
                $tileOffsetX, $tileOffsetY,
                $actualTileWidth, $actualTileHeight,
                $skipReason
            );
        }
    }

    echo "\nTotal tiles that will be generated: " . ($simulatedTileNum - 1) . "\n";

    echo "</pre>";
    exit; // Stop before PDF generation to see debug output
    */

    // Use the orientation and paper size determined by calculateTileGrid
    $frontPaper = $frontTileGrid['paper'];
    $frontOrientation = $frontTileGrid['orientation'];

    if ($frontTileGrid['totalTiles'] == 1) {
        // Single page (Portrait)
        $pdf->AddPage($frontOrientation, [$frontPaper['width'], $frontPaper['height']]);
        addCMLogo($pdf, $frontPaper['width'], $frontPaper['height']);
        addWatermark($pdf, $frontPaper['width'], $frontPaper['height'], '1. BLOUSE FRONT', $customerName);
        addTileReference($pdf, $frontPaper['width'], $frontPaper['height'], 1, 1, 'Front', $margin);

        // Render SVG at 1:1 scale (actual size - test scale accuracy first)
        // The viewBox is now tight-fitted, so use those dimensions directly
        $renderWidth = $frontDims['width'];
        $renderHeight = $frontDims['height'];
        $pdf->ImageSVG('@' . $frontSVG, $startX, $startY, $renderWidth, $renderHeight, '', '', '', 0, false);
    } else {
        // Multi-page tiling (Landscape)
        // Note: Tiling not needed with bounding box fix - patterns should fit on single page
        // This code remains for edge cases with very large patterns
        $tileNumber = 1;

        for ($ty = 0; $ty < $frontTileGrid['tilesY']; $ty++) {
            for ($tx = 0; $tx < $frontTileGrid['tilesX']; $tx++) {
                // Calculate tile offset (relative to pattern content)
                $tileOffsetX = $tx * $frontTileGrid['usableWidth'];
                $tileOffsetY = $ty * $frontTileGrid['usableHeight'];

                // Calculate actual tile dimensions (may be smaller at edges)
                $actualTileWidth = min($frontTileGrid['usableWidth'], $frontDims['width'] - $tileOffsetX);
                $actualTileHeight = min($frontTileGrid['usableHeight'], $frontDims['height'] - $tileOffsetY);

                // Skip tiles that are outside the pattern area
                if ($tileOffsetX >= $frontDims['width'] || $tileOffsetY >= $frontDims['height']) {
                    continue;
                }

                // Skip tiles with no content (very small dimensions)
                if ($actualTileWidth < 0.1 || $actualTileHeight < 0.1) {
                    continue;
                }

                $pdf->AddPage($frontOrientation, [$frontPaper['width'], $frontPaper['height']]);
                addCMLogo($pdf, $frontPaper['width'], $frontPaper['height']);
                addWatermark($pdf, $frontPaper['width'], $frontPaper['height'],
                           sprintf('1. BLOUSE FRONT (Tile %d of %d)', $tileNumber, $frontTileGrid['totalTiles']),
                           $customerName);
                addTileReference($pdf, $frontPaper['width'], $frontPaper['height'], $tileNumber, $frontTileGrid['totalTiles'], 'Front', $margin);

                // For tiling, we DON'T use pattern offset - just tile offset
                // The SVG's native viewBox already positions the content correctly
                $tileSVG = modifySVGForTile($frontSVG,
                                           $tileOffsetX, $tileOffsetY,
                                           $actualTileWidth, $actualTileHeight, $scale);

                // Render tile at 1:1 scale (actual size for testing)
                $tileRenderWidth = $actualTileWidth;
                $tileRenderHeight = $actualTileHeight;
                $pdf->ImageSVG('@' . $tileSVG, $startX, $startY, $tileRenderWidth, $tileRenderHeight, '', '', '', 0, false);

                // Add registration marks and diagonal alignment lines for multi-page tiling
                addRegistrationMarks($pdf, $frontPaper['width'], $frontPaper['height'], $margin, $tx, $ty, $frontTileGrid['tilesX'], $frontTileGrid['tilesY']);
                addDiagonalAlignmentLines($pdf, $frontPaper['width'], $frontPaper['height'], $margin, $tx, $ty, $frontTileGrid['tilesX'], $frontTileGrid['tilesY']);

                $tileNumber++;
            }
        }
    }
}

// =============================================================================
// PATTERN 2: BACK
// =============================================================================

if (isset($patternData['back']['svg_content'])) {
    $backSVG = $patternData['back']['svg_content'];
    $backDims = getSVGDimensions($backSVG, $scale);
    $backTileGrid = calculateTileGrid($backDims['width'], $backDims['height'],
                                     $paperSizes[$paperSize]['portrait'],
                                     $paperSizes[$paperSize]['landscape'],
                                     $margin);

    // DEBUG: Uncomment to see Back pattern tiling calculations
    /*
    echo "<pre style='background: #e0f0ff; padding: 20px; margin: 20px; border: 2px solid #006;'>";
    echo "<h3>BACK PATTERN DEBUG</h3>";
    echo "Pattern dimensions: {$backDims['width']}\" × {$backDims['height']}\"\n";
    echo "Orientation chosen: " . ($backTileGrid['orientation'] == 'P' ? 'Portrait' : 'Landscape') . "\n";
    echo "Total tiles: {$backTileGrid['totalTiles']}\n";
    echo "</pre>";
    */

    $backPaper = $backTileGrid['paper'];
    $backOrientation = $backTileGrid['orientation'];

    if ($backTileGrid['totalTiles'] == 1) {
        // Single page
        $pdf->AddPage($backOrientation, [$backPaper['width'], $backPaper['height']]);
        addCMLogo($pdf, $backPaper['width'], $backPaper['height']);
        addWatermark($pdf, $backPaper['width'], $backPaper['height'], '2. BLOUSE BACK', $customerName);
        addTileReference($pdf, $backPaper['width'], $backPaper['height'], 1, 1, 'Back', $margin);

        // Render SVG at 1:1 scale (actual size - test scale accuracy first)
        // The viewBox is now tight-fitted, so use those dimensions directly
        $renderWidth = $backDims['width'];
        $renderHeight = $backDims['height'];
        $pdf->ImageSVG('@' . $backSVG, $startX, $startY, $renderWidth, $renderHeight, '', '', '', 0, false);
    } else {
        // Multi-page tiling
        $tileNumber = 1;

        for ($ty = 0; $ty < $backTileGrid['tilesY']; $ty++) {
            for ($tx = 0; $tx < $backTileGrid['tilesX']; $tx++) {
                // Calculate tile offset
                $tileOffsetX = $tx * $backTileGrid['usableWidth'];
                $tileOffsetY = $ty * $backTileGrid['usableHeight'];

                // Calculate actual tile dimensions (may be smaller at edges)
                $actualTileWidth = min($backTileGrid['usableWidth'], $backDims['width'] - $tileOffsetX);
                $actualTileHeight = min($backTileGrid['usableHeight'], $backDims['height'] - $tileOffsetY);

                // Skip tiles that are outside the pattern area
                if ($tileOffsetX >= $backDims['width'] || $tileOffsetY >= $backDims['height']) {
                    continue;
                }

                // Skip tiles with no content (very small dimensions)
                if ($actualTileWidth < 0.1 || $actualTileHeight < 0.1) {
                    continue;
                }

                $pdf->AddPage($backOrientation, [$backPaper['width'], $backPaper['height']]);
                addCMLogo($pdf, $backPaper['width'], $backPaper['height']);
                addWatermark($pdf, $backPaper['width'], $backPaper['height'],
                           sprintf('2. BLOUSE BACK (Tile %d of %d)', $tileNumber, $backTileGrid['totalTiles']),
                           $customerName);
                addTileReference($pdf, $backPaper['width'], $backPaper['height'], $tileNumber, $backTileGrid['totalTiles'], 'Back', $margin);

                // Modify SVG viewBox for this tile
                // Note: Use tile offset only, not pattern offset
                $tileSVG = modifySVGForTile($backSVG,
                                           $tileOffsetX, $tileOffsetY,
                                           $actualTileWidth, $actualTileHeight, $scale);

                // Render tile at 1:1 scale (actual size for testing)
                $tileRenderWidth = $actualTileWidth;
                $tileRenderHeight = $actualTileHeight;
                $pdf->ImageSVG('@' . $tileSVG, $startX, $startY, $tileRenderWidth, $tileRenderHeight, '', '', '', 0, false);

                // Add registration marks and diagonal alignment lines for multi-page tiling
                addRegistrationMarks($pdf, $backPaper['width'], $backPaper['height'], $margin, $tx, $ty, $backTileGrid['tilesX'], $backTileGrid['tilesY']);
                addDiagonalAlignmentLines($pdf, $backPaper['width'], $backPaper['height'], $margin, $tx, $ty, $backTileGrid['tilesX'], $backTileGrid['tilesY']);

                $tileNumber++;
            }
        }
    }
}

// =============================================================================
// PATTERN 3: PATTI
// =============================================================================

if (isset($patternData['patti']['svg_content'])) {
    $pattiSVG = $patternData['patti']['svg_content'];
    $pattiDims = getSVGDimensions($pattiSVG, $scale);
    $pattiTileGrid = calculateTileGrid($pattiDims['width'], $pattiDims['height'],
                                      $paperSizes[$paperSize]['portrait'],
                                      $paperSizes[$paperSize]['landscape'],
                                      $margin);

    // DEBUG: Uncomment to see Patti pattern tiling calculations
    /*
    echo "<pre style='background: #ffe0f0; padding: 20px; margin: 20px; border: 2px solid #606;'>";
    echo "<h3>PATTI PATTERN DEBUG</h3>";
    echo "Pattern dimensions: {$pattiDims['width']}\" × {$pattiDims['height']}\"\n";
    echo "Orientation chosen: " . ($pattiTileGrid['orientation'] == 'P' ? 'Portrait' : 'Landscape') . "\n";
    echo "Total tiles: {$pattiTileGrid['totalTiles']}\n";
    echo "</pre>";
    */

    $pattiPaper = $pattiTileGrid['paper'];
    $pattiOrientation = $pattiTileGrid['orientation'];

    if ($pattiTileGrid['totalTiles'] == 1) {
        // Single page
        $pdf->AddPage($pattiOrientation, [$pattiPaper['width'], $pattiPaper['height']]);
        addCMLogo($pdf, $pattiPaper['width'], $pattiPaper['height']);
        addWatermark($pdf, $pattiPaper['width'], $pattiPaper['height'], '3. PATTI', $customerName);
        addTileReference($pdf, $pattiPaper['width'], $pattiPaper['height'], 1, 1, 'Patti', $margin);

        // Render SVG at 1:1 scale (actual size - test scale accuracy first)
        // Use SVG canvas dimensions for rendering, not bounding box (to maintain proper scale)
        // The viewBox is now tight-fitted, so use those dimensions directly
        $renderWidth = $pattiDims['width'];
        $renderHeight = $pattiDims['height'];
        $pdf->ImageSVG('@' . $pattiSVG, $startX, $startY, $renderWidth, $renderHeight, '', '', '', 0, false);
    } else {
        // Multi-page tiling
        $tileNumber = 1;

        for ($ty = 0; $ty < $pattiTileGrid['tilesY']; $ty++) {
            for ($tx = 0; $tx < $pattiTileGrid['tilesX']; $tx++) {
                // Calculate tile offset
                $tileOffsetX = $tx * $pattiTileGrid['usableWidth'];
                $tileOffsetY = $ty * $pattiTileGrid['usableHeight'];

                // Calculate actual tile dimensions (may be smaller at edges)
                $actualTileWidth = min($pattiTileGrid['usableWidth'], $pattiDims['width'] - $tileOffsetX);
                $actualTileHeight = min($pattiTileGrid['usableHeight'], $pattiDims['height'] - $tileOffsetY);

                // Skip tiles that are outside the pattern area
                if ($tileOffsetX >= $pattiDims['width'] || $tileOffsetY >= $pattiDims['height']) {
                    continue;
                }

                // Skip tiles with no content (very small dimensions)
                if ($actualTileWidth < 0.1 || $actualTileHeight < 0.1) {
                    continue;
                }

                $pdf->AddPage($pattiOrientation, [$pattiPaper['width'], $pattiPaper['height']]);
                addCMLogo($pdf, $pattiPaper['width'], $pattiPaper['height']);
                addWatermark($pdf, $pattiPaper['width'], $pattiPaper['height'],
                           sprintf('3. PATTI (Tile %d of %d)', $tileNumber, $pattiTileGrid['totalTiles']),
                           $customerName);
                addTileReference($pdf, $pattiPaper['width'], $pattiPaper['height'], $tileNumber, $pattiTileGrid['totalTiles'], 'Patti', $margin);

                // Modify SVG viewBox for this tile
                // Note: Use tile offset only, not pattern offset
                $tileSVG = modifySVGForTile($pattiSVG,
                                           $tileOffsetX, $tileOffsetY,
                                           $actualTileWidth, $actualTileHeight, $scale);

                // Render tile at 1:1 scale (actual size for testing)
                $tileRenderWidth = $actualTileWidth;
                $tileRenderHeight = $actualTileHeight;
                $pdf->ImageSVG('@' . $tileSVG, $startX, $startY, $tileRenderWidth, $tileRenderHeight, '', '', '', 0, false);

                // Add registration marks and diagonal alignment lines for multi-page tiling
                addRegistrationMarks($pdf, $pattiPaper['width'], $pattiPaper['height'], $margin, $tx, $ty, $pattiTileGrid['tilesX'], $pattiTileGrid['tilesY']);
                addDiagonalAlignmentLines($pdf, $pattiPaper['width'], $pattiPaper['height'], $margin, $tx, $ty, $pattiTileGrid['tilesX'], $pattiTileGrid['tilesY']);

                $tileNumber++;
            }
        }
    }
}

// =============================================================================
// PATTERN 4: SLEEVE
// =============================================================================

if (isset($patternData['sleeve']['svg_content'])) {
    $sleeveSVG = $patternData['sleeve']['svg_content'];
    $sleeveDims = getSVGDimensions($sleeveSVG, $scale);
    $sleeveTileGrid = calculateTileGrid($sleeveDims['width'], $sleeveDims['height'],
                                       $paperSizes[$paperSize]['portrait'],
                                       $paperSizes[$paperSize]['landscape'],
                                       $margin);

    // DEBUG: Uncomment to see Sleeve pattern tiling calculations
    /*
    echo "<pre style='background: #f0ffe0; padding: 20px; margin: 20px; border: 2px solid #060;'>";
    echo "<h3>SLEEVE PATTERN DEBUG</h3>";
    echo "Pattern dimensions: {$sleeveDims['width']}\" × {$sleeveDims['height']}\"\n";
    echo "Orientation chosen: " . ($sleeveTileGrid['orientation'] == 'P' ? 'Portrait' : 'Landscape') . "\n";
    echo "Total tiles: {$sleeveTileGrid['totalTiles']}\n";
    echo "</pre>";
    */

    $sleevePaper = $sleeveTileGrid['paper'];
    $sleeveOrientation = $sleeveTileGrid['orientation'];

    if ($sleeveTileGrid['totalTiles'] == 1) {
        // Single page
        $pdf->AddPage($sleeveOrientation, [$sleevePaper['width'], $sleevePaper['height']]);
        addCMLogo($pdf, $sleevePaper['width'], $sleevePaper['height']);
        addWatermark($pdf, $sleevePaper['width'], $sleevePaper['height'], '4. SLEEVE', $customerName);
        addTileReference($pdf, $sleevePaper['width'], $sleevePaper['height'], 1, 1, 'Sleeve', $margin);

        // Render SVG at 1:1 scale (actual size - test scale accuracy first)
        // The viewBox is now tight-fitted, so use those dimensions directly
        $renderWidth = $sleeveDims['width'];
        $renderHeight = $sleeveDims['height'];
        $pdf->ImageSVG('@' . $sleeveSVG, $startX, $startY, $renderWidth, $renderHeight, '', '', '', 0, false);
    } else {
        // Multi-page tiling
        $tileNumber = 1;

        for ($ty = 0; $ty < $sleeveTileGrid['tilesY']; $ty++) {
            for ($tx = 0; $tx < $sleeveTileGrid['tilesX']; $tx++) {
                // Calculate tile offset
                $tileOffsetX = $tx * $sleeveTileGrid['usableWidth'];
                $tileOffsetY = $ty * $sleeveTileGrid['usableHeight'];

                // Calculate actual tile dimensions (may be smaller at edges)
                $actualTileWidth = min($sleeveTileGrid['usableWidth'], $sleeveDims['width'] - $tileOffsetX);
                $actualTileHeight = min($sleeveTileGrid['usableHeight'], $sleeveDims['height'] - $tileOffsetY);

                // Skip tiles that are outside the pattern area
                if ($tileOffsetX >= $sleeveDims['width'] || $tileOffsetY >= $sleeveDims['height']) {
                    continue;
                }

                // Skip tiles with no content (very small dimensions)
                if ($actualTileWidth < 0.1 || $actualTileHeight < 0.1) {
                    continue;
                }

                $pdf->AddPage($sleeveOrientation, [$sleevePaper['width'], $sleevePaper['height']]);
                addCMLogo($pdf, $sleevePaper['width'], $sleevePaper['height']);
                addWatermark($pdf, $sleevePaper['width'], $sleevePaper['height'],
                           sprintf('4. SLEEVE (Tile %d of %d)', $tileNumber, $sleeveTileGrid['totalTiles']),
                           $customerName);
                addTileReference($pdf, $sleevePaper['width'], $sleevePaper['height'], $tileNumber, $sleeveTileGrid['totalTiles'], 'Sleeve', $margin);

                // Modify SVG viewBox for this tile
                // Note: Use tile offset only, not pattern offset
                $tileSVG = modifySVGForTile($sleeveSVG,
                                           $tileOffsetX, $tileOffsetY,
                                           $actualTileWidth, $actualTileHeight, $scale);

                // Render tile at 1:1 scale (actual size for testing)
                $tileRenderWidth = $actualTileWidth;
                $tileRenderHeight = $actualTileHeight;
                $pdf->ImageSVG('@' . $tileSVG, $startX, $startY, $tileRenderWidth, $tileRenderHeight, '', '', '', 0, false);

                // Add registration marks and diagonal alignment lines for multi-page tiling
                addRegistrationMarks($pdf, $sleevePaper['width'], $sleevePaper['height'], $margin, $tx, $ty, $sleeveTileGrid['tilesX'], $sleeveTileGrid['tilesY']);
                addDiagonalAlignmentLines($pdf, $sleevePaper['width'], $sleevePaper['height'], $margin, $tx, $ty, $sleeveTileGrid['tilesX'], $sleeveTileGrid['tilesY']);

                $tileNumber++;
            }
        }
    }
}

// =============================================================================
// OUTPUT PDF
// =============================================================================

// Clear output buffer
ob_end_clean();

// Output PDF - Force download to Downloads folder
// The pattern-download.php page will show a helpful modal after download starts
$pdf->Output($pdfFilename, 'D');
exit;
